// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

// This file is generated DO NOT EDIT @generated

#include <tgmath.h>
#include <cstdint>
#include <exception>
#include <iostream>
#include <list>
#include <map>
#include <regex>
#include <set>
#include <string>

#include <folly/Format.h>
#include <utility>
#include "presto_cpp/external/json/nlohmann/json.hpp"
#include "presto_cpp/presto_protocol/DataSize.h"
#include "presto_cpp/presto_protocol/Duration.h"
#include "velox/common/encode/Base64.h"

using nlohmann::json;

namespace facebook::presto::protocol {

extern const char* const PRESTO_PAGES_MIME_TYPE;

extern const char* const PRESTO_CURRENT_STATE_HTTP_HEADER;
extern const char* const PRESTO_MAX_WAIT_HTTP_HEADER;
extern const char* const PRESTO_MAX_SIZE_HTTP_HEADER;
extern const char* const PRESTO_TASK_INSTANCE_ID_HEADER;
extern const char* const PRESTO_PAGE_TOKEN_HEADER;
extern const char* const PRESTO_PAGE_NEXT_TOKEN_HEADER;
extern const char* const PRESTO_BUFFER_COMPLETE_HEADER;
extern const char* const PRESTO_GET_DATA_SIZE_HEADER;
extern const char* const PRESTO_BUFFER_REMAINING_BYTES_HEADER;

extern const char* const PRESTO_MAX_WAIT_DEFAULT;
extern const char* const PRESTO_MAX_SIZE_DEFAULT;

extern const char* const PRESTO_ABORT_TASK_URL_PARAM;

class Exception : public std::runtime_error {
 public:
  explicit Exception(const std::string& message)
      : std::runtime_error(message){};
};

class TypeError : public Exception {
 public:
  explicit TypeError(const std::string& message) : Exception(message){};
};

class OutOfRange : public Exception {
 public:
  explicit OutOfRange(const std::string& message) : Exception(message){};
};
class ParseError : public Exception {
 public:
  explicit ParseError(const std::string& message) : Exception(message){};
};

using String = std::string;
using Integer = int;
using Long = int64_t;
using boolean = bool;

template <typename T>
using List = std::vector<T>;
template <typename T>
using Set = std::set<T>;
template <typename K, typename V>
using Map = std::map<K, V>;

// These will have to be customized
//
using UUID = std::string;

using Subfield = std::string;
using HiveType = std::string;
using Type = std::string;

using DateTime = std::string;
using Locale = std::string;
using TimeZoneKey = long;
using URI = std::string;
using SqlFunctionId = std::string;

using QualifiedObjectName = std::string;
using TypeSignature = std::string;

using ConnectorId = std::string;
using MemoryPoolId = std::string;
using OutputBufferId = std::string;
using PlanFragmentId = std::string;
using PlanNodeId = std::string;
using QueryId = std::string;
using TaskId = std::string;
using TransactionId = std::string;
struct RuntimeMetric;
using RuntimeStats = Map<String, RuntimeMetric>;
using SplitWeight = int64_t;
struct SourceLocation;

template <typename T>
void to_json_key(json& j, const char* key, const T& value) {
  j[key] = value;
}

template <typename T>
void to_json_key(json& j, const char* key, const std::shared_ptr<T>& value) {
  if (value != nullptr) {
    j[key] = value;
  }
}

template <typename T>
void to_json_key(
    json& j,
    const char* key,
    const T& value,
    const char* className,
    const char* typeName,
    const char* fieldName) {
  try {
    to_json_key(j, key, value);
  } catch (json::type_error& e) {
    throw TypeError(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  }
}

template <typename T>
void from_json_key(const json& j, const char* key, T& value) {
  j.at(key).get_to(value);
}

template <typename T>
void from_json_key(const json& j, const char* key, std::shared_ptr<T>& value) {
  if (j.count(key)) {
    j.at(key).get_to(value);
  }
}

template <typename T>
void from_json_key(
    const json& j,
    const char* key,
    T& value,
    const char* className,
    const char* typeName,
    const char* fieldName) {
  try {
    from_json_key(j, key, value);
  } catch (json::type_error& e) {
    throw TypeError(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  } catch (json::out_of_range& e) {
    throw OutOfRange(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  }
}

struct KeyedSubclass {
  std::string _type; // This member holds the subtype that was serialized.

  std::string getSubclassKey(const json& j);
  virtual ~KeyedSubclass() {}
};

struct JsonEncodedSubclass : public KeyedSubclass {
  std::string getSubclassKey(const json& j);
};

struct Base64EncodedSubclass : public KeyedSubclass {
  std::string getSubclassKey(const json& j);

  virtual bool operator<(const Base64EncodedSubclass& /* o */) const {
    throw std::runtime_error("missing operator<() in Base64EncodedSubclass");
  }
};

} // namespace facebook::presto::protocol

namespace nlohmann {
std::string json_map_key(const std::string p);

template <typename T>
void to_json(json& j, const std::shared_ptr<T>& p) {
  j = *p;
}
template <typename T>
void from_json(const json& j, std::shared_ptr<T>& p) {
  p = std::make_shared<T>();
  j.get_to(*p);
}

template <typename V>
struct adl_serializer<facebook::presto::protocol::Map<int, V>> {
  static void to_json(
      json& j,
      const facebook::presto::protocol::Map<int, V>& p) {
    j = json::object();
    for (auto& el : p) {
      j[std::to_string(el.first)] = el.second;
    }
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::Map<int, V>& p) {
    for (auto& el : j.items()) {
      p.insert(std::pair<int, V>(std::stoi(el.key()), el.value().get<V>()));
    }
  }
};

template <typename K, typename V>
struct adl_serializer<facebook::presto::protocol::Map<K, V>> {
  static void to_json(json& j, const facebook::presto::protocol::Map<K, V>& p) {
    j = json::object();
    for (auto& el : p) {
      j[json_map_key(el.first)] = el.second;
    }
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::Map<K, V>& p) {
    for (auto& el : j.items()) {
      p.insert(std::pair<K, V>(K(el.key()), el.value().get<V>()));
    }
  }
};
} // namespace nlohmann

// Forward declaration of all abstract types
//
namespace facebook::presto::protocol {
struct ColumnHandle : public JsonEncodedSubclass {
  virtual bool operator<(const ColumnHandle& /* o */) const {
    throw std::runtime_error("missing operator<() in {class_name} subclass");
  }
};
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p);
void from_json(const json& j, std::shared_ptr<ColumnHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RowExpression : public JsonEncodedSubclass {
  std::shared_ptr<SourceLocation> sourceLocation = {};
};
void to_json(json& j, const std::shared_ptr<RowExpression>& p);
void from_json(const json& j, std::shared_ptr<RowExpression>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanNode : public JsonEncodedSubclass {
  PlanNodeId id = {};
};
void to_json(json& j, const std::shared_ptr<PlanNode>& p);
void from_json(const json& j, std::shared_ptr<PlanNode>& p);
} // namespace facebook::presto::protocol

namespace facebook::presto::protocol {
enum class ChangelogOperation { INSERT, DELETE, UPDATE_BEFORE, UPDATE_AFTER };
extern void to_json(json& j, const ChangelogOperation& e);
extern void from_json(const json& j, ChangelogOperation& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class TypeCategory { PRIMITIVE, STRUCT, ARRAY, MAP };
extern void to_json(json& j, const TypeCategory& e);
extern void from_json(const json& j, TypeCategory& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ColumnIdentity {
  int id = {};
  String name = {};
  TypeCategory typeCategory = {};
  List<ColumnIdentity> children = {};
};
void to_json(json& j, const ColumnIdentity& p);
void from_json(const json& j, ColumnIdentity& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IcebergColumnHandle : public ColumnHandle {
  ColumnIdentity columnIdentity = {};
  Type type = {};
  std::shared_ptr<String> comment = {};
  ColumnType columnType = {};
  List<Subfield> requiredSubfields = {};

  IcebergColumnHandle() noexcept;
};
void to_json(json& j, const IcebergColumnHandle& p);
void from_json(const json& j, IcebergColumnHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ChangelogSplitInfo {
  ChangelogOperation operation = {};
  int64_t ordinal = {};
  int64_t snapshotId = {};
  List<IcebergColumnHandle> icebergColumns = {};
};
void to_json(json& j, const ChangelogSplitInfo& p);
void from_json(const json& j, ChangelogSplitInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class FileContent { DATA, POSITION_DELETES, EQUALITY_DELETES };
extern void to_json(json& j, const FileContent& e);
extern void from_json(const json& j, FileContent& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class FileFormat { ORC, PARQUET, AVRO, METADATA };
extern void to_json(json& j, const FileFormat& e);
extern void from_json(const json& j, FileFormat& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DeleteFile {
  FileContent content = {};
  String path = {};
  FileFormat format = {};
  int64_t recordCount = {};
  int64_t fileSizeInBytes = {};
  List<Integer> equalityFieldIds = {};
  Map<Integer, String> lowerBounds = {};
  Map<Integer, String> upperBounds = {};
};
void to_json(json& j, const DeleteFile& p);
void from_json(const json& j, DeleteFile& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IcebergSplit : public ConnectorSplit {
  String path = {};
  int64_t start = {};
  int64_t length = {};
  FileFormat fileFormat = {};
  List<HostAddress> addresses = {};
  Map<Integer, HivePartitionKey> partitionKeys = {};
  String partitionSpecAsJson = {};
  std::shared_ptr<String> partitionDataJson = {};
  NodeSelectionStrategy nodeSelectionStrategy = {};
  SplitWeight splitWeight = {};
  List<DeleteFile> deletes = {};
  std::shared_ptr<ChangelogSplitInfo> changelogSplitInfo = {};
  int64_t dataSequenceNumber = {};

  IcebergSplit() noexcept;
};
void to_json(json& j, const IcebergSplit& p);
void from_json(const json& j, IcebergSplit& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class IcebergTableType {
  DATA,
  HISTORY,
  SNAPSHOTS,
  MANIFESTS,
  PARTITIONS,
  FILES,
  PROPERTIES,
  CHANGELOG,
  EQUALITY_DELETES,
  DATA_WITHOUT_EQUALITY_DELETES
};
extern void to_json(json& j, const IcebergTableType& e);
extern void from_json(const json& j, IcebergTableType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IcebergTableName {
  String tableName = {};
  IcebergTableType tableType = {};
  std::shared_ptr<Long> snapshotId = {};
  std::shared_ptr<Long> changelogEndSnapshot = {};
};
void to_json(json& j, const IcebergTableName& p);
void from_json(const json& j, IcebergTableName& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IcebergTableHandle : public ConnectorTableHandle {
  String schemaName = {};
  IcebergTableName icebergTableName = {};
  bool snapshotSpecified = {};
  std::shared_ptr<String> outputPath = {};
  std::shared_ptr<Map<String, String>> storageProperties = {};
  std::shared_ptr<String> tableSchemaJson = {};
  std::shared_ptr<List<Integer>> partitionFieldIds = {};
  std::shared_ptr<List<Integer>> equalityFieldIds = {};

  IcebergTableHandle() noexcept;
};
void to_json(json& j, const IcebergTableHandle& p);
void from_json(const json& j, IcebergTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IcebergTableLayoutHandle : public ConnectorTableLayoutHandle {
  List<IcebergColumnHandle> partitionColumns = {};
  List<Column> dataColumns = {};
  TupleDomain<Subfield> domainPredicate = {};
  std::shared_ptr<RowExpression> remainingPredicate = {};
  Map<String, IcebergColumnHandle> predicateColumns = {};
  std::shared_ptr<List<IcebergColumnHandle>> requestedColumns = {};
  bool pushdownFilterEnabled = {};
  TupleDomain<std::shared_ptr<ColumnHandle>> partitionColumnPredicate = {};
  IcebergTableHandle table = {};

  IcebergTableLayoutHandle() noexcept;
};
void to_json(json& j, const IcebergTableLayoutHandle& p);
void from_json(const json& j, IcebergTableLayoutHandle& p);
} // namespace facebook::presto::protocol
