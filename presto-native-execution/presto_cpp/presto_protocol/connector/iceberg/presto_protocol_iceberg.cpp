// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// presto_protocol.prolog.cpp
//

// This file is generated DO NOT EDIT @generated

#include <folly/Format.h>
#include <iostream>

#include "presto_cpp/presto_protocol/ConnectorProtocol.h"
#include "presto_cpp/presto_protocol/presto_protocol.h"

using namespace std::string_literals;

namespace nlohmann {
std::string json_map_key(std::string p) {
  return p;
}
} // namespace nlohmann

namespace facebook::presto::protocol {

const char* const PRESTO_PAGES_MIME_TYPE = "application/x-presto-pages";

const char* const PRESTO_CURRENT_STATE_HTTP_HEADER = "X-Presto-Current-State";
const char* const PRESTO_MAX_WAIT_HTTP_HEADER = "X-Presto-Max-Wait";
const char* const PRESTO_MAX_SIZE_HTTP_HEADER = "X-Presto-Max-Size";
const char* const PRESTO_TASK_INSTANCE_ID_HEADER = "X-Presto-Task-Instance-Id";
const char* const PRESTO_PAGE_TOKEN_HEADER = "X-Presto-Page-Sequence-Id";
const char* const PRESTO_PAGE_NEXT_TOKEN_HEADER =
    "X-Presto-Page-End-Sequence-Id";
const char* const PRESTO_BUFFER_COMPLETE_HEADER = "X-Presto-Buffer-Complete";
const char* const PRESTO_GET_DATA_SIZE_HEADER = "X-Presto-Get-Data-Size";
const char* const PRESTO_BUFFER_REMAINING_BYTES_HEADER =
    "X-Presto-Buffer-Remaining-Bytes";

const char* const PRESTO_MAX_WAIT_DEFAULT = "2s";
const char* const PRESTO_MAX_SIZE_DEFAULT = "4096 B";

const char* const PRESTO_ABORT_TASK_URL_PARAM = "abort";

std::string json_map_key(const VariableReferenceExpression& p) {
  return fmt::format("{}<{}>", p.name, p.type);
}
} // namespace facebook::presto::protocol

namespace facebook::presto::protocol {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ChangelogOperation, json>
    ChangelogOperation_enum_table[] = { // NOLINT: cert-err58-cpp
        {ChangelogOperation::INSERT, "INSERT"},
        {ChangelogOperation::DELETE, "DELETE"},
        {ChangelogOperation::UPDATE_BEFORE, "UPDATE_BEFORE"},
        {ChangelogOperation::UPDATE_AFTER, "UPDATE_AFTER"}};
void to_json(json& j, const ChangelogOperation& e) {
  static_assert(
      std::is_enum<ChangelogOperation>::value,
      "ChangelogOperation must be an enum!");
  const auto* it = std::find_if(
      std::begin(ChangelogOperation_enum_table),
      std::end(ChangelogOperation_enum_table),
      [e](const std::pair<ChangelogOperation, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ChangelogOperation_enum_table))
           ? it
           : std::begin(ChangelogOperation_enum_table))
          ->second;
}
void from_json(const json& j, ChangelogOperation& e) {
  static_assert(
      std::is_enum<ChangelogOperation>::value,
      "ChangelogOperation must be an enum!");
  const auto* it = std::find_if(
      std::begin(ChangelogOperation_enum_table),
      std::end(ChangelogOperation_enum_table),
      [&j](const std::pair<ChangelogOperation, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ChangelogOperation_enum_table))
           ? it
           : std::begin(ChangelogOperation_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<TypeCategory, json> TypeCategory_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {TypeCategory::PRIMITIVE, "PRIMITIVE"},
        {TypeCategory::STRUCT, "STRUCT"},
        {TypeCategory::ARRAY, "ARRAY"},
        {TypeCategory::MAP, "MAP"}};
void to_json(json& j, const TypeCategory& e) {
  static_assert(
      std::is_enum<TypeCategory>::value, "TypeCategory must be an enum!");
  const auto* it = std::find_if(
      std::begin(TypeCategory_enum_table),
      std::end(TypeCategory_enum_table),
      [e](const std::pair<TypeCategory, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(TypeCategory_enum_table))
           ? it
           : std::begin(TypeCategory_enum_table))
          ->second;
}
void from_json(const json& j, TypeCategory& e) {
  static_assert(
      std::is_enum<TypeCategory>::value, "TypeCategory must be an enum!");
  const auto* it = std::find_if(
      std::begin(TypeCategory_enum_table),
      std::end(TypeCategory_enum_table),
      [&j](const std::pair<TypeCategory, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(TypeCategory_enum_table))
           ? it
           : std::begin(TypeCategory_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ColumnIdentity& p) {
  j = json::object();
  to_json_key(j, "id", p.id, "ColumnIdentity", "int", "id");
  to_json_key(j, "name", p.name, "ColumnIdentity", "String", "name");
  to_json_key(
      j,
      "typeCategory",
      p.typeCategory,
      "ColumnIdentity",
      "TypeCategory",
      "typeCategory");
  to_json_key(
      j,
      "children",
      p.children,
      "ColumnIdentity",
      "List<ColumnIdentity>",
      "children");
}

void from_json(const json& j, ColumnIdentity& p) {
  from_json_key(j, "id", p.id, "ColumnIdentity", "int", "id");
  from_json_key(j, "name", p.name, "ColumnIdentity", "String", "name");
  from_json_key(
      j,
      "typeCategory",
      p.typeCategory,
      "ColumnIdentity",
      "TypeCategory",
      "typeCategory");
  from_json_key(
      j,
      "children",
      p.children,
      "ColumnIdentity",
      "List<ColumnIdentity>",
      "children");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IcebergColumnHandle::IcebergColumnHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergColumnHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "columnIdentity",
      p.columnIdentity,
      "IcebergColumnHandle",
      "ColumnIdentity",
      "columnIdentity");
  to_json_key(j, "type", p.type, "IcebergColumnHandle", "Type", "type");
  to_json_key(
      j, "comment", p.comment, "IcebergColumnHandle", "String", "comment");
  to_json_key(
      j,
      "columnType",
      p.columnType,
      "IcebergColumnHandle",
      "ColumnType",
      "columnType");
  to_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "IcebergColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
}

void from_json(const json& j, IcebergColumnHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "columnIdentity",
      p.columnIdentity,
      "IcebergColumnHandle",
      "ColumnIdentity",
      "columnIdentity");
  from_json_key(j, "type", p.type, "IcebergColumnHandle", "Type", "type");
  from_json_key(
      j, "comment", p.comment, "IcebergColumnHandle", "String", "comment");
  from_json_key(
      j,
      "columnType",
      p.columnType,
      "IcebergColumnHandle",
      "ColumnType",
      "columnType");
  from_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "IcebergColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ChangelogSplitInfo& p) {
  j = json::object();
  to_json_key(
      j,
      "operation",
      p.operation,
      "ChangelogSplitInfo",
      "ChangelogOperation",
      "operation");
  to_json_key(
      j, "ordinal", p.ordinal, "ChangelogSplitInfo", "int64_t", "ordinal");
  to_json_key(
      j,
      "snapshotId",
      p.snapshotId,
      "ChangelogSplitInfo",
      "int64_t",
      "snapshotId");
  to_json_key(
      j,
      "icebergColumns",
      p.icebergColumns,
      "ChangelogSplitInfo",
      "List<IcebergColumnHandle>",
      "icebergColumns");
}

void from_json(const json& j, ChangelogSplitInfo& p) {
  from_json_key(
      j,
      "operation",
      p.operation,
      "ChangelogSplitInfo",
      "ChangelogOperation",
      "operation");
  from_json_key(
      j, "ordinal", p.ordinal, "ChangelogSplitInfo", "int64_t", "ordinal");
  from_json_key(
      j,
      "snapshotId",
      p.snapshotId,
      "ChangelogSplitInfo",
      "int64_t",
      "snapshotId");
  from_json_key(
      j,
      "icebergColumns",
      p.icebergColumns,
      "ChangelogSplitInfo",
      "List<IcebergColumnHandle>",
      "icebergColumns");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<FileContent, json> FileContent_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {FileContent::DATA, "DATA"},
        {FileContent::POSITION_DELETES, "POSITION_DELETES"},
        {FileContent::EQUALITY_DELETES, "EQUALITY_DELETES"}};
void to_json(json& j, const FileContent& e) {
  static_assert(
      std::is_enum<FileContent>::value, "FileContent must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileContent_enum_table),
      std::end(FileContent_enum_table),
      [e](const std::pair<FileContent, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(FileContent_enum_table))
           ? it
           : std::begin(FileContent_enum_table))
          ->second;
}
void from_json(const json& j, FileContent& e) {
  static_assert(
      std::is_enum<FileContent>::value, "FileContent must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileContent_enum_table),
      std::end(FileContent_enum_table),
      [&j](const std::pair<FileContent, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(FileContent_enum_table))
           ? it
           : std::begin(FileContent_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<FileFormat, json> FileFormat_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {FileFormat::ORC, "ORC"},
        {FileFormat::PARQUET, "PARQUET"},
        {FileFormat::AVRO, "AVRO"},
        {FileFormat::METADATA, "METADATA"}};
void to_json(json& j, const FileFormat& e) {
  static_assert(std::is_enum<FileFormat>::value, "FileFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileFormat_enum_table),
      std::end(FileFormat_enum_table),
      [e](const std::pair<FileFormat, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(FileFormat_enum_table))
           ? it
           : std::begin(FileFormat_enum_table))
          ->second;
}
void from_json(const json& j, FileFormat& e) {
  static_assert(std::is_enum<FileFormat>::value, "FileFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileFormat_enum_table),
      std::end(FileFormat_enum_table),
      [&j](const std::pair<FileFormat, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(FileFormat_enum_table))
           ? it
           : std::begin(FileFormat_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DeleteFile& p) {
  j = json::object();
  to_json_key(j, "content", p.content, "DeleteFile", "FileContent", "content");
  to_json_key(j, "path", p.path, "DeleteFile", "String", "path");
  to_json_key(j, "format", p.format, "DeleteFile", "FileFormat", "format");
  to_json_key(
      j, "recordCount", p.recordCount, "DeleteFile", "int64_t", "recordCount");
  to_json_key(
      j,
      "fileSizeInBytes",
      p.fileSizeInBytes,
      "DeleteFile",
      "int64_t",
      "fileSizeInBytes");
  to_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "DeleteFile",
      "List<Integer>",
      "equalityFieldIds");
  to_json_key(
      j,
      "lowerBounds",
      p.lowerBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "lowerBounds");
  to_json_key(
      j,
      "upperBounds",
      p.upperBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "upperBounds");
}

void from_json(const json& j, DeleteFile& p) {
  from_json_key(
      j, "content", p.content, "DeleteFile", "FileContent", "content");
  from_json_key(j, "path", p.path, "DeleteFile", "String", "path");
  from_json_key(j, "format", p.format, "DeleteFile", "FileFormat", "format");
  from_json_key(
      j, "recordCount", p.recordCount, "DeleteFile", "int64_t", "recordCount");
  from_json_key(
      j,
      "fileSizeInBytes",
      p.fileSizeInBytes,
      "DeleteFile",
      "int64_t",
      "fileSizeInBytes");
  from_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "DeleteFile",
      "List<Integer>",
      "equalityFieldIds");
  from_json_key(
      j,
      "lowerBounds",
      p.lowerBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "lowerBounds");
  from_json_key(
      j,
      "upperBounds",
      p.upperBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "upperBounds");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IcebergSplit::IcebergSplit() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergSplit& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(j, "path", p.path, "IcebergSplit", "String", "path");
  to_json_key(j, "start", p.start, "IcebergSplit", "int64_t", "start");
  to_json_key(j, "length", p.length, "IcebergSplit", "int64_t", "length");
  to_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergSplit",
      "FileFormat",
      "fileFormat");
  to_json_key(
      j,
      "addresses",
      p.addresses,
      "IcebergSplit",
      "List<HostAddress>",
      "addresses");
  to_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "IcebergSplit",
      "Map<Integer, HivePartitionKey>",
      "partitionKeys");
  to_json_key(
      j,
      "partitionSpecAsJson",
      p.partitionSpecAsJson,
      "IcebergSplit",
      "String",
      "partitionSpecAsJson");
  to_json_key(
      j,
      "partitionDataJson",
      p.partitionDataJson,
      "IcebergSplit",
      "String",
      "partitionDataJson");
  to_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "IcebergSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  to_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "IcebergSplit",
      "SplitWeight",
      "splitWeight");
  to_json_key(
      j, "deletes", p.deletes, "IcebergSplit", "List<DeleteFile>", "deletes");
  to_json_key(
      j,
      "changelogSplitInfo",
      p.changelogSplitInfo,
      "IcebergSplit",
      "ChangelogSplitInfo",
      "changelogSplitInfo");
  to_json_key(
      j,
      "dataSequenceNumber",
      p.dataSequenceNumber,
      "IcebergSplit",
      "int64_t",
      "dataSequenceNumber");
}

void from_json(const json& j, IcebergSplit& p) {
  p._type = j["@type"];
  from_json_key(j, "path", p.path, "IcebergSplit", "String", "path");
  from_json_key(j, "start", p.start, "IcebergSplit", "int64_t", "start");
  from_json_key(j, "length", p.length, "IcebergSplit", "int64_t", "length");
  from_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergSplit",
      "FileFormat",
      "fileFormat");
  from_json_key(
      j,
      "addresses",
      p.addresses,
      "IcebergSplit",
      "List<HostAddress>",
      "addresses");
  from_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "IcebergSplit",
      "Map<Integer, HivePartitionKey>",
      "partitionKeys");
  from_json_key(
      j,
      "partitionSpecAsJson",
      p.partitionSpecAsJson,
      "IcebergSplit",
      "String",
      "partitionSpecAsJson");
  from_json_key(
      j,
      "partitionDataJson",
      p.partitionDataJson,
      "IcebergSplit",
      "String",
      "partitionDataJson");
  from_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "IcebergSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  from_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "IcebergSplit",
      "SplitWeight",
      "splitWeight");
  from_json_key(
      j, "deletes", p.deletes, "IcebergSplit", "List<DeleteFile>", "deletes");
  from_json_key(
      j,
      "changelogSplitInfo",
      p.changelogSplitInfo,
      "IcebergSplit",
      "ChangelogSplitInfo",
      "changelogSplitInfo");
  from_json_key(
      j,
      "dataSequenceNumber",
      p.dataSequenceNumber,
      "IcebergSplit",
      "int64_t",
      "dataSequenceNumber");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<IcebergTableType, json> IcebergTableType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {IcebergTableType::DATA, "DATA"},
        {IcebergTableType::HISTORY, "HISTORY"},
        {IcebergTableType::SNAPSHOTS, "SNAPSHOTS"},
        {IcebergTableType::MANIFESTS, "MANIFESTS"},
        {IcebergTableType::PARTITIONS, "PARTITIONS"},
        {IcebergTableType::FILES, "FILES"},
        {IcebergTableType::PROPERTIES, "PROPERTIES"},
        {IcebergTableType::CHANGELOG, "CHANGELOG"},
        {IcebergTableType::EQUALITY_DELETES, "EQUALITY_DELETES"},
        {IcebergTableType::DATA_WITHOUT_EQUALITY_DELETES,
         "DATA_WITHOUT_EQUALITY_DELETES"}};
void to_json(json& j, const IcebergTableType& e) {
  static_assert(
      std::is_enum<IcebergTableType>::value,
      "IcebergTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(IcebergTableType_enum_table),
      std::end(IcebergTableType_enum_table),
      [e](const std::pair<IcebergTableType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(IcebergTableType_enum_table))
           ? it
           : std::begin(IcebergTableType_enum_table))
          ->second;
}
void from_json(const json& j, IcebergTableType& e) {
  static_assert(
      std::is_enum<IcebergTableType>::value,
      "IcebergTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(IcebergTableType_enum_table),
      std::end(IcebergTableType_enum_table),
      [&j](const std::pair<IcebergTableType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(IcebergTableType_enum_table))
           ? it
           : std::begin(IcebergTableType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const IcebergTableName& p) {
  j = json::object();
  to_json_key(
      j, "tableName", p.tableName, "IcebergTableName", "String", "tableName");
  to_json_key(
      j,
      "tableType",
      p.tableType,
      "IcebergTableName",
      "IcebergTableType",
      "tableType");
  to_json_key(
      j, "snapshotId", p.snapshotId, "IcebergTableName", "Long", "snapshotId");
  to_json_key(
      j,
      "changelogEndSnapshot",
      p.changelogEndSnapshot,
      "IcebergTableName",
      "Long",
      "changelogEndSnapshot");
}

void from_json(const json& j, IcebergTableName& p) {
  from_json_key(
      j, "tableName", p.tableName, "IcebergTableName", "String", "tableName");
  from_json_key(
      j,
      "tableType",
      p.tableType,
      "IcebergTableName",
      "IcebergTableType",
      "tableType");
  from_json_key(
      j, "snapshotId", p.snapshotId, "IcebergTableName", "Long", "snapshotId");
  from_json_key(
      j,
      "changelogEndSnapshot",
      p.changelogEndSnapshot,
      "IcebergTableName",
      "Long",
      "changelogEndSnapshot");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IcebergTableHandle::IcebergTableHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergTableHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "icebergTableName",
      p.icebergTableName,
      "IcebergTableHandle",
      "IcebergTableName",
      "icebergTableName");
  to_json_key(
      j,
      "snapshotSpecified",
      p.snapshotSpecified,
      "IcebergTableHandle",
      "bool",
      "snapshotSpecified");
  to_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergTableHandle",
      "String",
      "outputPath");
  to_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergTableHandle",
      "Map<String, String>",
      "storageProperties");
  to_json_key(
      j,
      "tableSchemaJson",
      p.tableSchemaJson,
      "IcebergTableHandle",
      "String",
      "tableSchemaJson");
  to_json_key(
      j,
      "partitionFieldIds",
      p.partitionFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "partitionFieldIds");
  to_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "equalityFieldIds");
}

void from_json(const json& j, IcebergTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "icebergTableName",
      p.icebergTableName,
      "IcebergTableHandle",
      "IcebergTableName",
      "icebergTableName");
  from_json_key(
      j,
      "snapshotSpecified",
      p.snapshotSpecified,
      "IcebergTableHandle",
      "bool",
      "snapshotSpecified");
  from_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergTableHandle",
      "String",
      "outputPath");
  from_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergTableHandle",
      "Map<String, String>",
      "storageProperties");
  from_json_key(
      j,
      "tableSchemaJson",
      p.tableSchemaJson,
      "IcebergTableHandle",
      "String",
      "tableSchemaJson");
  from_json_key(
      j,
      "partitionFieldIds",
      p.partitionFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "partitionFieldIds");
  from_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "equalityFieldIds");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "hive") {
    j = *std::static_pointer_cast<HiveColumnHandle>(p);
    return;
  }
  if (type == "hive-iceberg") {
    j = *std::static_pointer_cast<IcebergColumnHandle>(p);
    return;
  }
  if (type == "tpch") {
    j = *std::static_pointer_cast<TpchColumnHandle>(p);
    return;
  }
  if (type == "$system@system") {
    j = *std::static_pointer_cast<SystemColumnHandle>(p);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}

void from_json(const json& j, std::shared_ptr<ColumnHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ColumnHandle  ColumnHandle");
  }

  if (type == "hive") {
    std::shared_ptr<HiveColumnHandle> k = std::make_shared<HiveColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }
  if (type == "hive-iceberg") {
    std::shared_ptr<IcebergColumnHandle> k =
        std::make_shared<IcebergColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }
  if (type == "tpch") {
    std::shared_ptr<TpchColumnHandle> k = std::make_shared<TpchColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }
  if (type == "$system@system") {
    std::shared_ptr<SystemColumnHandle> k =
        std::make_shared<SystemColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<RowExpression>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "call") {
    j = *std::static_pointer_cast<CallExpression>(p);
    return;
  }
  if (type == "constant") {
    j = *std::static_pointer_cast<ConstantExpression>(p);
    return;
  }
  if (type == "special") {
    j = *std::static_pointer_cast<SpecialFormExpression>(p);
    return;
  }
  if (type == "lambda") {
    j = *std::static_pointer_cast<LambdaDefinitionExpression>(p);
    return;
  }
  if (type == "variable") {
    j = *std::static_pointer_cast<VariableReferenceExpression>(p);
    return;
  }

  throw TypeError(type + " no abstract type RowExpression ");
}

void from_json(const json& j, std::shared_ptr<RowExpression>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " RowExpression  RowExpression");
  }

  if (type == "call") {
    std::shared_ptr<CallExpression> k = std::make_shared<CallExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "constant") {
    std::shared_ptr<ConstantExpression> k =
        std::make_shared<ConstantExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "special") {
    std::shared_ptr<SpecialFormExpression> k =
        std::make_shared<SpecialFormExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "lambda") {
    std::shared_ptr<LambdaDefinitionExpression> k =
        std::make_shared<LambdaDefinitionExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "variable") {
    std::shared_ptr<VariableReferenceExpression> k =
        std::make_shared<VariableReferenceExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }

  throw TypeError(type + " no abstract type RowExpression ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IcebergTableLayoutHandle::IcebergTableLayoutHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergTableLayoutHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "partitionColumns");
  to_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "IcebergTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  to_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  to_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "IcebergTableLayoutHandle",
      "RowExpression",
      "remainingPredicate");
  to_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "IcebergTableLayoutHandle",
      "Map<String, IcebergColumnHandle>",
      "predicateColumns");
  to_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "requestedColumns");
  to_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "IcebergTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  to_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  to_json_key(
      j,
      "table",
      p.table,
      "IcebergTableLayoutHandle",
      "IcebergTableHandle",
      "table");
}

void from_json(const json& j, IcebergTableLayoutHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "partitionColumns");
  from_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "IcebergTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  from_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  from_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "IcebergTableLayoutHandle",
      "RowExpression",
      "remainingPredicate");
  from_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "IcebergTableLayoutHandle",
      "Map<String, IcebergColumnHandle>",
      "predicateColumns");
  from_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "requestedColumns");
  from_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "IcebergTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  from_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  from_json_key(
      j,
      "table",
      p.table,
      "IcebergTableLayoutHandle",
      "IcebergTableHandle",
      "table");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<PlanNode>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == ".AggregationNode") {
    j = *std::static_pointer_cast<AggregationNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.GroupIdNode") {
    j = *std::static_pointer_cast<GroupIdNode>(p);
    return;
  }
  if (type == ".DistinctLimitNode") {
    j = *std::static_pointer_cast<DistinctLimitNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode") {
    j = *std::static_pointer_cast<EnforceSingleRowNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.ExchangeNode") {
    j = *std::static_pointer_cast<ExchangeNode>(p);
    return;
  }
  if (type == ".FilterNode") {
    j = *std::static_pointer_cast<FilterNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.JoinNode") {
    j = *std::static_pointer_cast<JoinNode>(p);
    return;
  }
  if (type == ".LimitNode") {
    j = *std::static_pointer_cast<LimitNode>(p);
    return;
  }
  if (type == ".MarkDistinctNode") {
    j = *std::static_pointer_cast<MarkDistinctNode>(p);
    return;
  }
  if (type == ".SortNode") {
    j = *std::static_pointer_cast<SortNode>(p);
    return;
  }
  if (type == ".OutputNode") {
    j = *std::static_pointer_cast<OutputNode>(p);
    return;
  }
  if (type == ".ProjectNode") {
    j = *std::static_pointer_cast<ProjectNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RowNumberNode") {
    j = *std::static_pointer_cast<RowNumberNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RemoteSourceNode") {
    j = *std::static_pointer_cast<RemoteSourceNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SampleNode") {
    j = *std::static_pointer_cast<SampleNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SemiJoinNode") {
    j = *std::static_pointer_cast<SemiJoinNode>(p);
    return;
  }
  if (type == ".TableScanNode") {
    j = *std::static_pointer_cast<TableScanNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterNode") {
    j = *std::static_pointer_cast<TableWriterNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterMergeNode") {
    j = *std::static_pointer_cast<TableWriterMergeNode>(p);
    return;
  }
  if (type == ".TopNNode") {
    j = *std::static_pointer_cast<TopNNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TopNRowNumberNode") {
    j = *std::static_pointer_cast<TopNRowNumberNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.UnnestNode") {
    j = *std::static_pointer_cast<UnnestNode>(p);
    return;
  }
  if (type == ".ValuesNode") {
    j = *std::static_pointer_cast<ValuesNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.AssignUniqueId") {
    j = *std::static_pointer_cast<AssignUniqueId>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.MergeJoinNode") {
    j = *std::static_pointer_cast<MergeJoinNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.WindowNode") {
    j = *std::static_pointer_cast<WindowNode>(p);
    return;
  }

  throw TypeError(type + " no abstract type PlanNode ");
}

void from_json(const json& j, std::shared_ptr<PlanNode>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " PlanNode  PlanNode");
  }

  if (type == ".AggregationNode") {
    std::shared_ptr<AggregationNode> k = std::make_shared<AggregationNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.GroupIdNode") {
    std::shared_ptr<GroupIdNode> k = std::make_shared<GroupIdNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".DistinctLimitNode") {
    std::shared_ptr<DistinctLimitNode> k =
        std::make_shared<DistinctLimitNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode") {
    std::shared_ptr<EnforceSingleRowNode> k =
        std::make_shared<EnforceSingleRowNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.ExchangeNode") {
    std::shared_ptr<ExchangeNode> k = std::make_shared<ExchangeNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".FilterNode") {
    std::shared_ptr<FilterNode> k = std::make_shared<FilterNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.JoinNode") {
    std::shared_ptr<JoinNode> k = std::make_shared<JoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".LimitNode") {
    std::shared_ptr<LimitNode> k = std::make_shared<LimitNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".MarkDistinctNode") {
    std::shared_ptr<MarkDistinctNode> k = std::make_shared<MarkDistinctNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".SortNode") {
    std::shared_ptr<SortNode> k = std::make_shared<SortNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".OutputNode") {
    std::shared_ptr<OutputNode> k = std::make_shared<OutputNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".ProjectNode") {
    std::shared_ptr<ProjectNode> k = std::make_shared<ProjectNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RowNumberNode") {
    std::shared_ptr<RowNumberNode> k = std::make_shared<RowNumberNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RemoteSourceNode") {
    std::shared_ptr<RemoteSourceNode> k = std::make_shared<RemoteSourceNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SampleNode") {
    std::shared_ptr<SampleNode> k = std::make_shared<SampleNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SemiJoinNode") {
    std::shared_ptr<SemiJoinNode> k = std::make_shared<SemiJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".TableScanNode") {
    std::shared_ptr<TableScanNode> k = std::make_shared<TableScanNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterNode") {
    std::shared_ptr<TableWriterNode> k = std::make_shared<TableWriterNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterMergeNode") {
    std::shared_ptr<TableWriterMergeNode> k =
        std::make_shared<TableWriterMergeNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".TopNNode") {
    std::shared_ptr<TopNNode> k = std::make_shared<TopNNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TopNRowNumberNode") {
    std::shared_ptr<TopNRowNumberNode> k =
        std::make_shared<TopNRowNumberNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.UnnestNode") {
    std::shared_ptr<UnnestNode> k = std::make_shared<UnnestNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".ValuesNode") {
    std::shared_ptr<ValuesNode> k = std::make_shared<ValuesNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.AssignUniqueId") {
    std::shared_ptr<AssignUniqueId> k = std::make_shared<AssignUniqueId>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.MergeJoinNode") {
    std::shared_ptr<MergeJoinNode> k = std::make_shared<MergeJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.WindowNode") {
    std::shared_ptr<WindowNode> k = std::make_shared<WindowNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }

  throw TypeError(type + " no abstract type PlanNode ");
}
} // namespace facebook::presto::protocol
